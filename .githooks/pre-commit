#!/bin/sh
LC_ALL=C
echo "Running pre-commit hook"

if git rev-parse --verify HEAD >/dev/null
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=`git hash-object -t tree /dev/null`
fi

# Redirect output to stderr
exec 1>&2

### Check for invalid characters in new files
echo "Checking for invalid characters in new files"
git diff --cached --name-only --diff-filter=A -z $against | while IFS= read -r -d '' filename; do
	if [[ $filename =~ "\\" ]]; then
		>&2 echo "The generated file \"${filename}\" contains invalid character '\'."
		exit 2
	fi
done

### Format C# files
echo "Checking for .editorconfig file"
if [ ! -f .editorconfig ]; then
	echo "No .editorconfig file found"
	exit 1
fi

echo "Checking for dotnet-format"
# Find the solution file in the root directory
SOLUTION_FILE=$(find . -maxdepth 1 -name "*.sln" | head -n 1)
[ -z "$SOLUTION_FILE" ] && echo "Solution file not found!" && exit 1

# Select files to format
FILES=$(git diff --cached --name-only --diff-filter=ACM "*.cs" | sed 's| |\\ |g')
if [ -n "$FILES" ]; then
	# Convert space-separated file paths into a comma-separated list
	FORMATTABLE_FILES=$(echo "$FILES" | tr '\n' ',' | sed 's/,$//')

	# Format the selected files using the workspace option
	dotnet format "$SOLUTION_FILE" --verbosity diagnostic --include "$FORMATTABLE_FILES"

	# Add back the modified files to staging
	echo "$FILES" | xargs git add
fi

### Check for large files
# ensure that there's not a >100mb file in this checkin, which github won't allow
echo "Checking for >100MB files"
CURRENT_DIR="$(pwd)"
HAS_ERROR=""
COMMIT_TEXT=$(git diff --cached --name-only | sort | uniq)
SAVEIFS=$IFS

IFS="
"
for file in $COMMIT_TEXT; do
	file_size=$(du -m $CURRENT_DIR/$file | awk '{print $1}')
	if [ "$file_size" -ge 100 ]; then
		echo "$file is over 100MB."
		HAS_ERROR="1"
	fi
done
IFS=$SAVEIFS

if [ "$HAS_ERROR" != "" ]; then
    echo "Can't commit, fix errors first." >&2
    exit 1
fi

### Check for staged files and their meta files
echo "Checking for staged files and their meta files"
git diff --cached --name-only --diff-filter=A -z $against -- "$ASSETS_DIR" | while read -d $'\0' f; do
	ext="${f##*.}"
	base="${f%.*}"

	if [ "$ext" = "meta" ]; then
		if [ $(git ls-files --cached -- "$base" | wc -l) = 0 ]; then
			cat <<EOF
Error: Redudant meta file.
Meta file \`$f' is added, but \`$base' is not in the git index.
Please add \`$base' to git as well.
EOF
			exit 1
		fi
	else
		p="$f"
		while [ "$p" != "$ASSETS_DIR" ]; do
			if [ $(git ls-files --cached -- "$p.meta" | wc -l) = 0 ]; then
				cat <<EOF
Error: Missing meta file.
Asset \`$f' is added, but \`$p.meta' is not in the git index.
Please add \`$p.meta' to git as well.
EOF
				exit 1
			fi
			p="${p%/*}"
		done
	fi
done

ret="$?"
if [ "$ret" != 0 ]; then
	exit "$ret"
fi

git diff --cached --name-only --diff-filter=D -z $against -- "$ASSETS_DIR" | while read -d $'\0' f; do
	ext="${f##*.}"
	base="${f%.*}"

	if [ "$ext" = "meta" ]; then
		if [ $(git ls-files --cached -- "$base" | wc -l) != 0 ]; then
			cat <<EOF
Error: Redudant meta file.
Meta file \`$f' is removed, but \`$base' is still in the git index.
Please remove \`$base' from git as well.
EOF
			exit 1
		fi
	else
		p="$f"
		while [ "$p" != "$ASSETS_DIR" ]; do
			if [ $(git ls-files --cached -- "$p" | wc -l) = 0 ] && [ $(git ls-files --cached -- "$p.meta" | wc -l) != 0 ]; then
				cat <<EOF
Error: Missing meta file.
Asset \`$f' is removed, but \`$p.meta' is still in the git index.
Please remove \`$p.meta' from git as well.
EOF
				exit 1
			fi
			p="${p%/*}"
		done
	fi
done

ret="$?"
if [ "$ret" != 0 ]; then
	exit "$ret"
fi

### Check for .gitignore and corresponding .meta files
# check if staged files contain .gitignore
if [ ! `git diff --name-only --cached | grep -- "\.gitignore"` ]; then
	# avoid expensive diff actions if there is no change in .gitignore
	exit 0
fi

# new lines have the format {+xxxxx+}
raw_diff_output=`git diff --cached --word-diff=plain .gitignore | egrep  "\{\+.*\+\}"`

# prepare two strings: one for directories and one for meta files
for raw_entry in $raw_diff_output; do
	# strip leading and trailing separator "{+" and "+}"
	if ((${#raw_entry} <= 4)); then
		continue
	else
		e=${raw_entry:2:$((${#raw_entry}-4))}
		is_meta=$((`echo $e | egrep ".*meta" | wc -l`))
		if [ $is_meta -eq 0 ]; then
			diff_output_dirs="${diff_output_dirs} ${e}"
		else
			diff_output_metas="${diff_output_metas} ${e}"
		fi
	fi
done

# iterate over directories and check if there is an entry for the appropriate meta file
for i in $diff_output_dirs; do 
	# meta file entries are often without directory, so strip the path
	dir_name=`echo $i | egrep -o "/[^/]+$" | cut -d / -f 2`
	echo $dir_name
	has_meta_ignore=$((`echo $diff_output_metas | grep -- "$dir_name.meta" | wc -l`))
	if [ ${has_meta_ignore} -eq 0 ]; then
		echo "$dir_name found in .gitignore but not the corresponding meta file! Please add ${dir_name}.meta to .gitignore"
		exit 1
	fi
done

exit 0
